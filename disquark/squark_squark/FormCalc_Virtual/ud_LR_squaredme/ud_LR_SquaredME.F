*#define CHECK

* ud_LR_SquaredME.F
* assembly of squared matrix element
* generated by FormCalc 6.1D0 11 Jun 2012 16:06

	subroutine ud_LR_SquaredME(result, helicities, flags)
	implicit none
	real*8 result !changed CH
	integer*8 helicities
	integer flags

#include "ud_LR_vars.h"

	double precision ud_LR_sumup
	external ud_LR_sumup

	integer Hel1, Hel2, Hel3, Hel4
	equivalence (Hel(1), Hel1)
	equivalence (Hel(2), Hel2)
	equivalence (Hel(3), Hel3)
	equivalence (Hel(4), Hel4)

	integer jSUNtree, nSUNtree
	parameter (nSUNtree = 8)

	integer jSUNloop, nSUNloop
	parameter (nSUNloop = 8)

	data MatSUN /64*bogus/

c  calculate the correct renconst:
	call ud_LR_CalcRenConst

	S = SInvariant(1,2)

	T = TInvariant(1,3)

	U = TInvariant(2,3)


#define RESET_IF if( btest(flags, 0) ) then
#define RESET_ENDIF endif

#define LOOP_IF if( btest(flags, 1) ) then
#define LOOP_ENDIF endif

#define HEL_IF(i) if( btest(helicities, 22-5*i+Hel(i)) ) then
#define HEL_ENDIF(i) endif

	RESET_IF
	call ud_LR_abbr0_s
	LOOP_IF
	call ud_LR_abbr1_s
	LOOP_ENDIF
	RESET_ENDIF

	call markcache

	LOOP_IF
	call ud_LR_abbr1_angle
	LOOP_ENDIF

! 	result(1) = 0 !CH
	result = 0.d0

	do Hel1 = -2, 2
	HEL_IF(1)
	do Hel2 = -2, 2
	HEL_IF(2)
	do Hel3 = -2, 2
	HEL_IF(3)
	do Hel4 = -2, 2
	HEL_IF(4)

	call ud_LR_abbr0_hel
	LOOP_IF
	call ud_LR_abbr1_hel
	LOOP_ENDIF

	do jSUNtree = 1, nSUNtree
	Ctree(jSUNtree) = 0
	enddo

	do jSUNloop = 1, nSUNloop
	Cloop(jSUNloop) = 0
	enddo

	call ud_LR_born

!CH: do not need born-squared here!
! 	result(1) = result(1) + ud_LR_sumup(Ctree, nSUNtree, Ctree, nSUNtree)

	LOOP_IF
	call ud_LR_self 
	call ud_LR_tri
	call ud_LR_box

	result = result + 2*ud_LR_sumup(Cloop, nSUNloop, Ctree, nSUNtree)
	LOOP_ENDIF

	HEL_ENDIF(4)
	enddo
	HEL_ENDIF(3)
	enddo
	HEL_ENDIF(2)
	enddo
	HEL_ENDIF(1)
	enddo

	call restorecache

#ifdef CHECK
	print *, 'S =', S
	print *, 'T =', T
	print *, 'U =', U
	print*, 'S+T+U =',S+T+U
	print*, 'sum_masses = ',mtemp1u1+mtemp2d1

! 	print *, 'tree =', result(1)
	print *, 'loop =', result
	stop
#endif
	end


************************************************************************

	double precision function ud_LR_sumup(CCloop, nSUNloop, CCtree, nSUNtree)
	implicit none

#include "ud_LR_vars.h"

	integer jSUNloop, nSUNloop
	integer jSUNtree, nSUNtree
	double complex CCloop(nSUNloop), CCtree(nSUNtree)
	double complex m

	ud_LR_sumup = 0

	do jSUNtree = 1, nSUNtree
	m = 0
	do jSUNloop = 1, nSUNloop
	m = m + CCloop(jSUNloop)*MatSUN(jSUNloop,jSUNtree)
	enddo
	ud_LR_sumup = ud_LR_sumup + DBLE(DCONJG(CCtree(jSUNtree))*m)
	enddo
	end
